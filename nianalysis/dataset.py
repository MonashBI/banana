import os.path
from nianalysis.data_formats import DataFormat
from copy import copy
from nipype.interfaces.base import traits
import subprocess as sp
from nianalysis.data_formats import (
    data_formats, data_formats_by_ext, data_formats_by_mrinfo, dicom_format)
from nianalysis.utils import split_extension
from logging import getLogger

logger = getLogger('NiAnalysis')


class Dataset(object):
    """
    A class representing a dataset, which was acquired.

    Parameters
    ----------
    name : str
        The name of the dataset
    format : FileFormat
        The file format used to store the dataset. Can be one of the
        recognised formats
    multiplicity : str
        One of 'per_subject', 'subject_subset', and 'per_project', specifying
        whether the dataset is present for each session, subject or project.
    """

    MULTIPLICITY_OPTIONS = ('per_session', 'per_subject', 'per_project')
    #                        'per_session_subset', 'per_subject_subset')

    def __init__(self, name, format=None, processed=False,  # @ReservedAssignment @IgnorePep8
                 multiplicity='per_session'):
        assert isinstance(name, basestring)
        assert isinstance(format, DataFormat)
        assert multiplicity in self.MULTIPLICITY_OPTIONS
        self._name = name
        self._format = format
        self._multiplicity = multiplicity
        self._processed = processed
        self._prefix = ''

    def __eq__(self, other):
        try:
            return (self.name == other.name and
                    self.format == other.format and
                    self.multiplicity == other.multiplicity and
                    self._prefix == other._prefix)
        except AttributeError as e:
            assert not e.message.startswith(
                "'{}'".format(self.__class__.__name__))
            return False

    def __ne__(self, other):
        return not (self == other)

    @property
    def name(self):
        return self._name

    @property
    def format(self):
        return self._format

    @property
    def multiplicity(self):
        return self._multiplicity

    @property
    def processed(self):
        return self._processed

    def __iter__(self):
        return iter(self.to_tuple())

    def to_tuple(self):
        return self.name, self.format.name, self.multiplicity, self.processed

    @classmethod
    def from_tuple(cls, tple):
        name, format_name, multiplicity, processed = tple
        data_format = data_formats[format_name]
        return cls(name, data_format, pipeline=processed,
                   multiplicity=multiplicity)

    @classmethod
    def from_path(cls, path, multiplicity='per_session'):
        basename, ext = split_extension(path)
        try:
            data_format = data_formats_by_ext[ext]
        except KeyError:
            # FIXME: Should handle DICOMs in different way. Maybe try to load
            #        with pydicom??
            cmd = ("mrinfo \"{}\" 2>/dev/null | grep Format | "
                   "awk '{{print $2}}'".format(path))
            abbrev = sp.check_output(cmd, shell=True).strip()
            try:
                data_format = data_formats_by_mrinfo[abbrev]
            except KeyError:
                logger.warning("Unrecognised format '{}' of path '{}'"
                               "assuming it is a dicom".format(abbrev, path))
                data_format = dicom_format
        return cls(basename, data_format, multiplicity=multiplicity)

    @property
    def filename(self, format=None):  # @ReservedAssignment
        if format is None:
            assert self.format is not None, "Dataset format is undefined"
            format = self.format  # @ReservedAssignment
        return self._prefix + self.name + format.extension

    def match(self, filename):
        base, ext = os.path.splitext(filename)
        return base == self.name and (ext == self.format.extension or
                                      self.format is None)

    def apply_prefix(self, prefix):
        """
        Duplicate the dataset and provide a prefix to apply to the filename
        """
        duplicate = copy(self)
        duplicate._prefix = prefix
        return duplicate

    def __repr__(self):
        return ("Dataset(name='{}', format={}, multiplicity={})"
                .format(self.name, self.format, self.multiplicity))


class DatasetSpec(Dataset):
    """
    A class representing a "specification" for a dataset within a study, which
    can either be an "acquired" dataset (e.g from the scanner)
    externally, or a "processed" dataset, which was generated by a processing
    pipeline.

    Parameters
    ----------
    name : str
        The name of the dataset
    format : FileFormat
        The file format used to store the dataset. Can be one of the
        recognised formats
    pipeline : Study.method
        The method of the study that is used to generate the dataset. If None
        the dataset is assumed to be acquired external
    multiplicity : str
        One of 'per_subject', 'subject_subset', and 'per_project', specifying
        whether the dataset is present for each session, subject or project.
    """

    def __init__(self, name, format=None, pipeline=None,  # @ReservedAssignment @IgnorePep8
                 multiplicity='per_session', description=None):
        assert isinstance(name, basestring)
        assert isinstance(format, DataFormat)
        assert multiplicity in self.MULTIPLICITY_OPTIONS
        self._name = name
        self._format = format
        self._multiplicity = multiplicity
        self._prefix = ''
        self._pipeline = pipeline
        self._description = description

    def __eq__(self, other):
        return (super(DatasetSpec, self).__eq__(other) and
                self.pipeline == other.pipeline)

    @property
    def pipeline(self):
        return self._pipeline

    @property
    def processed(self):
        return self._pipeline is not None

    @property
    def description(self):
        return self._description

    def to_tuple(self):
        return self.name, self.format.name, self.multiplicity, self.processed

    def renamed_copy(self, name):
        cpy = copy(self)
        cpy._name = name
        return cpy

    @classmethod
    def traits_spec(self):
        """
        Return the specification for a Dataset as a tuple
        """
        return traits.Tuple(  # @UndefinedVariable
            traits.Str(  # @UndefinedVariable
                mandatory=True,
                desc="name of file"),
            traits.Str(  # @UndefinedVariable
                mandatory=True,
                desc="name of the dataset format"),
            traits.Str(mandatory=True,  # @UndefinedVariable @IgnorePep8
                       desc="multiplicity of the dataset (one of '{}')".format(
                            "', '".join(self.MULTIPLICITY_OPTIONS))),
            traits.Bool(mandatory=True,  # @UndefinedVariable @IgnorePep8
                        desc=("whether the file was generate by a pipeline "
                              "or not")))

    def __repr__(self):
        return ("DatasetSpec(name='{}', format={}, pipeline={}, "
                "multiplicity={})".format(
                    self.name, self.format, self.pipeline, self.multiplicity))
